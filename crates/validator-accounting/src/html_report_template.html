<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Block Parliament · Validator Financials</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* ── bp-web manpage / paper aesthetic ── */
    :root {
      --paper: #f8f6f1;
      --ink: #1a1a1a;
      --ink-light: #666;
      --link: #0066cc;
      --rule: #ccc;
      --green: #227a4b;
      --red: #b91c1c;
      --neutral: #888;
      --header-offset: 0px;
      --timeline-commission: #2563eb;
      --timeline-leader: #0ea5e9;
      --timeline-mev: #6366f1;
      --timeline-bam: #0891b2;
      --timeline-vote: #b45309;
      --timeline-doublezero: #c2410c;
      --timeline-expense: #b45309;
      --timeline-expense-hosting: #ea580c;
      --timeline-expense-software: #d97706;
      --timeline-expense-contractor: #c2410c;
      --timeline-expense-hardware: #9a3412;
      --timeline-expense-other: #b45309;
      --timeline-seeding: #64748b;
      --timeline-withdrawal: #475569;
      --timeline-dz-payment: #52525b;
      --timeline-tax-revenue: #2563eb;
      --timeline-tax-reimbursement: #0891b2;
      --timeline-tax-return-capital: #64748b;
      --timeline-tax-expense-vote-fees: #b45309;
      --timeline-tax-expense-doublezero: #c2410c;
      --timeline-tax-expense-hosting: #ea580c;
      --timeline-tax-expense-software: #d97706;
      --timeline-tax-expense-contractor: #9a3412;
      --timeline-tax-expense-hardware: #92400e;
      --timeline-tax-expense-other: #b45309;
      --timeline-other: #6b7280;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --paper: #1a1a1a;
        --ink: #e8e6e1;
        --ink-light: #999;
        --link: #6db3f2;
        --rule: #444;
        --green: #34d399;
        --red: #f87171;
        --neutral: #777;
        --timeline-commission: #60a5fa;
        --timeline-leader: #38bdf8;
        --timeline-mev: #818cf8;
        --timeline-bam: #22d3ee;
        --timeline-vote: #f59e0b;
        --timeline-doublezero: #fb923c;
        --timeline-expense: #f59e0b;
        --timeline-expense-hosting: #fb923c;
        --timeline-expense-software: #fbbf24;
        --timeline-expense-contractor: #fdba74;
        --timeline-expense-hardware: #f97316;
        --timeline-expense-other: #f59e0b;
        --timeline-seeding: #94a3b8;
        --timeline-withdrawal: #cbd5e1;
        --timeline-dz-payment: #a1a1aa;
        --timeline-tax-revenue: #60a5fa;
        --timeline-tax-reimbursement: #22d3ee;
        --timeline-tax-return-capital: #94a3b8;
        --timeline-tax-expense-vote-fees: #f59e0b;
        --timeline-tax-expense-doublezero: #fb923c;
        --timeline-tax-expense-hosting: #fdba74;
        --timeline-tax-expense-software: #fbbf24;
        --timeline-tax-expense-contractor: #fed7aa;
        --timeline-tax-expense-hardware: #f97316;
        --timeline-tax-expense-other: #f59e0b;
        --timeline-other: #9ca3af;
      }
    }

    body {
      background-color: var(--paper);
      color: var(--ink);
      font-family: monospace;
      font-size: 14px;
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
    }

    a {
      color: var(--link);
      text-decoration: underline;
      text-underline-offset: 2px;
    }

    a:hover {
      text-decoration-thickness: 2px;
    }

    ::selection {
      background-color: var(--ink);
      color: var(--paper);
    }

    @media print {
      body {
        background: white;
        color: black;
      }

      a {
        color: black;
      }

      #header {
        position: static;
        backdrop-filter: none;
      }
    }

    /* ── Sticky header ── */
    #header {
      position: sticky;
      top: 0;
      z-index: 100;
      background-color: var(--paper);
      border-bottom: 1px dashed var(--rule);
      padding: 12px 20px 10px;
    }

    @supports (backdrop-filter: blur(1px)) {
      #header {
        background-color: color-mix(in srgb, var(--paper) 85%, transparent);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
      }
    }

    .header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .header-title {
      font-size: 12px;
      font-weight: bold;
      letter-spacing: 0.08em;
      color: var(--ink-light);
      text-transform: uppercase;
    }

    .unit-toggle {
      display: flex;
      gap: 4px;
    }

    .mode-toggle {
      display: flex;
      gap: 4px;
    }

    .unit-btn,
    .mode-btn {
      background: none;
      border: 1px dashed var(--rule);
      color: var(--ink-light);
      padding: 2px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 11px;
      transition: all 0.15s;
    }

    .unit-btn:hover,
    .mode-btn:hover {
      border-color: var(--ink);
      color: var(--ink);
    }

    .unit-btn.active,
    .mode-btn.active {
      background: var(--ink);
      border-color: var(--ink);
      border-style: solid;
      color: var(--paper);
    }

    .stats-row {
      display: flex;
      gap: 12px;
      margin-bottom: 12px;
    }

    .stat-card {
      flex: 1;
      border: 1px dashed var(--rule);
      padding: 10px 14px;
    }

    .stat-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--ink-light);
      margin-bottom: 2px;
    }

    .stat-value {
      font-size: 22px;
      font-weight: bold;
      font-variant-numeric: tabular-nums;
      letter-spacing: -0.02em;
      transition: color 0.2s;
      margin-top: 4px;
      line-height: 1.1;
      min-height: 1.2em;
      display: block;
    }

    .stat-value.positive {
      color: var(--green);
    }

    .stat-value.negative {
      color: var(--red);
    }

    .stat-value.neutral {
      color: var(--ink);
    }

    .header-filters {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: flex-start;
    }

    .date-range-tabs {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      min-width: 0;
      flex: 1;
    }

    .type-filters {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
      min-width: 260px;
    }

    .type-group-tabs,
    .type-sub-tabs {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .filter-btn {
      background: none;
      border: 1px dashed var(--rule);
      color: var(--ink-light);
      padding: 2px 12px;
      cursor: pointer;
      font-family: monospace;
      font-size: 11px;
      transition: all 0.15s;
    }

    .filter-btn:hover {
      border-color: var(--ink);
      color: var(--ink);
    }

    .filter-btn.active {
      background: var(--ink);
      border-color: var(--ink);
      border-style: solid;
      color: var(--paper);
    }

    /* ── Layout ── */
    #content-layout {
      width: min(100%, 1800px);
      margin: 20px auto 0;
      padding: 0 clamp(12px, 2vw, 24px);
      display: grid;
      grid-template-columns: minmax(460px, 1.05fr) minmax(560px, 1.35fr);
      gap: clamp(16px, 2vw, 28px);
      align-items: start;
      transition: opacity 180ms ease, transform 180ms ease;
    }

    #content-layout.ui-updating {
      opacity: 0.86;
      transform: translateY(2px);
    }

    /* ── Timeline ── */
    #timeline {
      max-width: none;
      margin: 0;
      padding: 0 0 8px;
      min-width: 0;
      overflow: visible;
    }

    #timeline-panel {
      min-width: 0;
      max-height: calc(100vh - var(--header-offset) - 34px);
      overflow-y: auto;
      overflow-x: hidden;
      overscroll-behavior: contain;
      scroll-padding-top: 10px;
      scrollbar-gutter: stable;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    #timeline-panel::-webkit-scrollbar {
      width: 0;
      height: 0;
      display: none;
    }

    .month-sep {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 16px 0 6px;
      padding: 6px 8px;
      position: sticky;
      top: 0;
      z-index: 4;
      background: var(--paper);
      border-bottom: 1px dashed var(--rule);
      animation: row-enter 160ms ease both;
    }

    .month-sep:first-child {
      margin-top: 0;
    }

    .month-sep-line {
      flex: 1;
      height: 0;
      border-top: 1px dashed var(--rule);
    }

    .month-sep-label {
      font-size: 11px;
      font-weight: bold;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--ink-light);
      white-space: nowrap;
    }

    .month-sep-net {
      font-size: 11px;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    .month-sep-net.positive {
      color: var(--green);
    }

    .month-sep-net.negative {
      color: var(--red);
    }

    .month-sep-net.neutral {
      color: var(--neutral);
    }

    /* ── Event rows ── */
    .event-row {
      display: grid;
      grid-template-columns: 62px 1fr auto auto;
      align-items: start;
      gap: 0 10px;
      padding: 5px 8px;
      transition: background 0.1s;
      animation: row-enter 160ms ease both;
    }

    .event-row:hover {
      background: color-mix(in srgb, var(--ink) 6%, var(--paper));
    }

    .row-anchor {
      background: color-mix(in srgb, var(--ink) 6%, var(--paper));
      box-shadow: inset 2px 0 0 var(--link);
    }

    .ev-date {
      font-size: 11px;
      color: var(--ink-light);
      font-variant-numeric: tabular-nums;
      padding-top: 1px;
    }

    .ev-dot {
      display: none;
    }

    .ev-label {
      min-width: 0;
    }

    .ev-label-main-wrap {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }

    .ev-label-main {
      font-size: 13px;
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .type-badge {
      --badge-color: var(--type-accent, var(--timeline-other));
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 6px;
      height: 16px;
      border: 1px solid color-mix(in srgb, var(--badge-color) 65%, var(--rule));
      border-radius: 999px;
      font-size: 9px;
      line-height: 1;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      white-space: nowrap;
      flex: 0 0 auto;
      color: var(--badge-color);
      background: color-mix(in srgb, var(--badge-color) 14%, var(--paper));
    }

    .type-badge.tone-income {
      opacity: 1;
    }

    .type-badge.tone-expense {
      opacity: 1;
    }

    .type-badge.tone-neutral {
      opacity: 0.84;
    }

    .type-badge.tone-review {
      text-decoration: underline dotted;
      text-underline-offset: 2px;
    }

    .type-badge[data-type="commission"] {
      --type-accent: var(--timeline-commission);
    }

    .type-badge[data-type="leader_fees"] {
      --type-accent: var(--timeline-leader);
    }

    .type-badge[data-type="mev"] {
      --type-accent: var(--timeline-mev);
    }

    .type-badge[data-type="bam"] {
      --type-accent: var(--timeline-bam);
    }

    .type-badge[data-type="vote_cost"] {
      --type-accent: var(--timeline-vote);
    }

    .type-badge[data-type="doublezero"] {
      --type-accent: var(--timeline-doublezero);
    }

    .type-badge[data-type="expense"] {
      --type-accent: var(--timeline-expense);
    }

    .type-badge[data-type="tax_revenue"] {
      --type-accent: var(--timeline-tax-revenue);
    }

    .type-badge[data-type="tax_reimbursement"] {
      --type-accent: var(--timeline-tax-reimbursement);
    }

    .type-badge[data-type="tax_return_capital"] {
      --type-accent: var(--timeline-tax-return-capital);
    }

    .type-badge[data-type="tax_expense_vote_fees"] {
      --type-accent: var(--timeline-tax-expense-vote-fees);
    }

    .type-badge[data-type="tax_expense_doublezero"] {
      --type-accent: var(--timeline-tax-expense-doublezero);
    }

    .type-badge[data-type="tax_expense_hosting"] {
      --type-accent: var(--timeline-tax-expense-hosting);
    }

    .type-badge[data-type="tax_expense_software"] {
      --type-accent: var(--timeline-tax-expense-software);
    }

    .type-badge[data-type="tax_expense_contractor"] {
      --type-accent: var(--timeline-tax-expense-contractor);
    }

    .type-badge[data-type="tax_expense_hardware"] {
      --type-accent: var(--timeline-tax-expense-hardware);
    }

    .type-badge[data-type="tax_expense_other"] {
      --type-accent: var(--timeline-tax-expense-other);
    }

    .type-badge[data-type="seeding"] {
      --type-accent: var(--timeline-seeding);
    }

    .type-badge[data-type="withdrawal"] {
      --type-accent: var(--timeline-withdrawal);
    }

    .type-badge[data-type="doublezero_payment"] {
      --type-accent: var(--timeline-dz-payment);
    }

    .ev-label-sub {
      font-size: 11px;
      color: var(--ink-light);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .ev-sol {
      text-align: right;
      font-size: 12px;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
      padding-top: 1px;
    }

    .ev-usd {
      text-align: right;
      font-size: 13px;
      font-weight: bold;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
      min-width: 80px;
      padding-top: 1px;
    }

    .ev-income .ev-sol,
    .ev-income .ev-usd {
      color: var(--green);
    }

    .ev-expense .ev-sol,
    .ev-expense .ev-usd {
      color: var(--red);
    }

    .ev-neutral .ev-sol,
    .ev-neutral .ev-usd {
      color: var(--neutral);
    }

    /* ── Dashboard ── */
    #dashboard-container {
      margin: 0;
      padding: 0;
      position: sticky;
      top: calc(var(--header-offset) + 14px);
    }

    .dashboard-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    .dashboard-card-main {
      grid-column: 1 / -1;
    }

    .dashboard-card {
      border: 1px dashed var(--rule);
      padding: 20px;
      display: flex;
      flex-direction: column;
    }

    .dashboard-card-title {
      font-size: 11px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--ink-light);
      margin-bottom: 16px;
    }

    .dashboard-chart-tall {
      height: clamp(240px, 32vh, 380px);
      position: relative;
    }

    .dashboard-chart {
      flex: 1;
      position: relative;
      min-height: 180px;
    }

    /* ── Section headers (ASCII box-drawing) ── */
    .section-title {
      font-weight: bold;
      text-transform: uppercase;
      font-size: 12px;
      letter-spacing: 0.06em;
      color: var(--ink-light);
      margin-bottom: 12px;
    }

    @media (max-width: 1280px) {
      #content-layout {
        grid-template-columns: 1fr;
        gap: 14px;
      }

      #dashboard-container {
        position: static;
      }

      .dashboard-grid {
        grid-template-columns: 1fr 1fr;
      }

      .dashboard-card-main {
        grid-column: 1 / -1;
      }

    }

    @media (max-width: 700px) {
      #header {
        padding: 10px 12px 8px;
      }

      .header-controls {
        gap: 6px;
      }

      .header-filters {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .type-filters {
        align-items: flex-start;
        min-width: 0;
      }

      .type-group-tabs,
      .type-sub-tabs {
        justify-content: flex-start;
      }

      #content-layout {
        margin-top: 12px;
        padding: 0 12px;
      }

      #dashboard-container {
        margin: 0;
        padding: 0;
      }

      .dashboard-grid {
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .stats-row {
        gap: 8px;
      }

      .stat-card {
        padding: 8px 10px;
      }

      .stat-value {
        font-size: 18px;
      }

      .dashboard-card {
        padding: 14px;
      }

      .dashboard-chart-tall {
        height: 200px;
      }

      .dashboard-chart {
        min-height: 150px;
      }

      #timeline {
        padding: 0 0 8px;
      }

    }

    @keyframes row-enter {
      from {
        opacity: 0;
        transform: translateY(4px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* ── Reduced motion ── */
    @media (prefers-reduced-motion: reduce) {

      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
  </style>
</head>

<body>

  <div id="header">
    <div class="header-top">
      <span class="header-title">&#x2500;&#x2524; Block Parliament · Validator Financials &#x251C;&#x2500;</span>
      <div class="header-controls">
        <div class="mode-toggle">
          <button class="mode-btn active" id="btn-mode-operating" onclick="setViewMode('operating')">Operating</button>
          <button class="mode-btn" id="btn-mode-tax" onclick="setViewMode('tax')">Tax</button>
        </div>
        <div class="unit-toggle">
          <button class="unit-btn active" id="btn-usd" onclick="setUnit('usd')">USD</button>
          <button class="unit-btn" id="btn-sol" onclick="setUnit('sol')">SOL</button>
        </div>
      </div>
    </div>

    <div class="header-filters">
      <div class="date-range-tabs" id="date-range-tabs">
        <!-- injected by JS -->
      </div>
      <div class="type-filters">
        <div class="type-group-tabs" id="type-group-tabs">
          <!-- injected by JS -->
        </div>
        <div class="type-sub-tabs" id="type-sub-tabs">
          <!-- injected by JS -->
        </div>
      </div>
    </div>
  </div>

  <div id="content-layout">
    <div id="dashboard-container">
      <div class="stats-row">
        <div class="stat-card">
          <div class="stat-label" id="label-profit">Net P/L</div>
          <div class="stat-value" id="stat-profit">$0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label" id="label-revenue">Revenue</div>
          <div class="stat-value" id="stat-revenue">$0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label" id="label-expenses">Expenses</div>
          <div class="stat-value" id="stat-expenses">$0</div>
        </div>
      </div>

      <div class="dashboard-grid">
        <!-- Main PnL Chart -->
        <div class="dashboard-card dashboard-card-main">
          <div class="dashboard-card-title" id="title-monthly">&#x2500;&#x2524; Net Monthly Performance &#x251C;&#x2500;</div>
          <div class="dashboard-chart-tall"><canvas id="chart-pnl"></canvas></div>
        </div>

        <!-- Revenue Breakdown -->
        <div class="dashboard-card">
          <div class="dashboard-card-title" id="title-income">&#x2500;&#x2524; Income Breakdown &#x251C;&#x2500;</div>
          <div class="dashboard-chart"><canvas id="chart-income"></canvas></div>
        </div>

        <!-- Expense Breakdown -->
        <div class="dashboard-card">
          <div class="dashboard-card-title" id="title-expense">&#x2500;&#x2524; Expense Breakdown &#x251C;&#x2500;</div>
          <div class="dashboard-chart"><canvas id="chart-expenses"></canvas></div>
        </div>
      </div>
    </div>

    <div id="timeline-panel">
      <div id="timeline"></div>
    </div>
  </div>

  <script>
    const TIMELINE = __TIMELINE_JSON__;
    const TAX_TIMELINE = __TAX_TIMELINE_JSON__;

    // ── Cached DOM refs ──────────────────────────────────────────────────────────
    const profitEl = document.getElementById('stat-profit');
    const revenueEl = document.getElementById('stat-revenue');
    const expensesEl = document.getElementById('stat-expenses');
    const profitLabelEl = document.getElementById('label-profit');
    const revenueLabelEl = document.getElementById('label-revenue');
    const expensesLabelEl = document.getElementById('label-expenses');
    const monthlyTitleEl = document.getElementById('title-monthly');
    const incomeTitleEl = document.getElementById('title-income');
    const expenseTitleEl = document.getElementById('title-expense');
    const dateRangeTabsEl = document.getElementById('date-range-tabs');
    const typeGroupTabsEl = document.getElementById('type-group-tabs');
    const typeSubTabsEl = document.getElementById('type-sub-tabs');
    const timelinePanelEl = document.getElementById('timeline-panel');

    // ── Detect dark mode for Chart.js theming ────────────────────────────────────
    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const chartInk = isDark ? '#e8e6e1' : '#1a1a1a';
    const chartInkLight = isDark ? '#999' : '#666';
    const chartRule = isDark ? '#444' : '#ccc';
    const chartPaper = isDark ? '#1a1a1a' : '#f8f6f1';
    const chartGreen = isDark ? '#34d399' : '#227a4b';
    const chartRed = isDark ? '#f87171' : '#b91c1c';

    // ── Chart.js Global Config ───────────────────────────────────────────────────
    Chart.defaults.color = chartInkLight;
    Chart.defaults.font.family = 'monospace';
    Chart.defaults.font.size = 11;
    Chart.defaults.scale.grid.color = chartRule;
    Chart.defaults.plugins.tooltip.backgroundColor = chartInk;
    Chart.defaults.plugins.tooltip.titleColor = chartPaper;
    Chart.defaults.plugins.tooltip.bodyColor = isDark ? '#ccc' : '#888';
    Chart.defaults.plugins.tooltip.padding = 10;
    Chart.defaults.plugins.tooltip.cornerRadius = 0;
    Chart.defaults.plugins.tooltip.displayColors = true;
    Chart.defaults.plugins.tooltip.borderColor = chartRule;
    Chart.defaults.plugins.tooltip.borderWidth = 1;
    Chart.defaults.animation.duration = 220;
    Chart.defaults.animation.easing = 'easeOutCubic';

    const chartColors = {
      commission: isDark ? '#f59e0b' : '#b45309',
      leader_fees: isDark ? '#60a5fa' : '#2563eb',
      mev: isDark ? '#a78bfa' : '#7c3aed',
      bam: isDark ? '#22d3ee' : '#0891b2',
      vote_cost: isDark ? '#fb923c' : '#c2410c',
      expense: chartRed,
      doublezero: isDark ? '#f43f5e' : '#be123c',
      tax_revenue: isDark ? '#60a5fa' : '#2563eb',
      tax_reimbursement: isDark ? '#22d3ee' : '#0891b2',
      tax_return_capital: isDark ? '#94a3b8' : '#64748b',
      tax_expense_vote_fees: isDark ? '#f59e0b' : '#b45309',
      tax_expense_doublezero: isDark ? '#fb923c' : '#c2410c',
      tax_expense_hosting: isDark ? '#fdba74' : '#ea580c',
      tax_expense_software: isDark ? '#fbbf24' : '#d97706',
      tax_expense_contractor: isDark ? '#fed7aa' : '#9a3412',
      tax_expense_hardware: isDark ? '#f97316' : '#92400e',
      tax_expense_other: isDark ? '#f59e0b' : '#b45309',
      other: isDark ? '#52525b' : '#888'
    };

    const typeLabels = {
      commission: 'Commission',
      leader_fees: 'Leader Fees',
      mev: 'MEV Tips',
      bam: 'BAM',
      vote_cost: 'Vote Costs',
      expense: 'Expenses',
      doublezero: 'DoubleZero Fees',
      seeding: 'Capital Contribution',
      withdrawal: 'Withdrawal',
      doublezero_payment: 'DoubleZero Prepayment',
      tax_revenue: 'Taxable Withdrawal',
      tax_reimbursement: 'SFDP Reimbursement',
      tax_return_capital: 'Return of Capital',
      tax_expense_vote_fees: 'Vote Fees',
      tax_expense_doublezero: 'DoubleZero',
      tax_expense_hosting: 'Hosting',
      tax_expense_software: 'Software',
      tax_expense_contractor: 'Contractor',
      tax_expense_hardware: 'Hardware',
      tax_expense_other: 'Other Expense',
    };

    const dateRangeOptions = [
      { id: 'all', label: 'All time' },
      { id: 'last_epoch', label: 'Last epoch' },
      { id: '30d', label: '30D' },
      { id: '90d', label: '90D' },
      { id: '2025', label: '2025' },
      { id: '2026', label: '2026' },
    ];

    const operatingTypeGroupOptions = [
      { id: 'all', label: 'All' },
      { id: 'revenue', label: 'Revenue' },
      { id: 'expenses', label: 'Expenses' },
      { id: 'non_pnl', label: 'Non-P&L' },
    ];

    const taxTypeGroupOptions = [
      { id: 'tax_events', label: 'Tax events' },
      { id: 'all', label: 'All rows' },
      { id: 'taxable_income', label: 'Taxable' },
      { id: 'deductible_expense', label: 'Deductible' },
      { id: 'reimbursement', label: 'Reimb.' },
      { id: 'non_taxable_transfer', label: 'Transfers' },
    ];

    const operatingSubtypeMap = {
      revenue: ['leader_fees', 'commission', 'mev', 'bam'],
      expenses: ['vote_cost', 'doublezero', 'expense'],
      non_pnl: ['seeding', 'withdrawal', 'doublezero_payment'],
    };

    const taxSubtypeMap = {
      tax_events: [
        'tax_revenue',
        'tax_expense_vote_fees',
        'tax_expense_doublezero',
        'tax_expense_hosting',
        'tax_expense_software',
        'tax_expense_contractor',
        'tax_expense_hardware',
        'tax_expense_other',
        'tax_reimbursement',
      ],
      taxable_income: ['tax_revenue'],
      deductible_expense: [
        'tax_expense_vote_fees',
        'tax_expense_doublezero',
        'tax_expense_hosting',
        'tax_expense_software',
        'tax_expense_contractor',
        'tax_expense_hardware',
        'tax_expense_other',
      ],
      reimbursement: ['tax_reimbursement'],
      non_taxable_transfer: ['tax_return_capital'],
    };

    let pnlChartInstance = null;
    let incomeChartInstance = null;
    let expenseChartInstance = null;
    let currentRenderedEvents = TIMELINE;
    let currentDateRange = 'all';
    let currentTypeGroup = 'all';
    let currentSubtype = 'all';
    let currentViewMode = 'operating';
    const breakdownPalette = isDark
      ? ['#fb923c', '#f43f5e', '#ef4444', '#eab308', '#14b8a6', '#22c55e', '#60a5fa', '#a78bfa']
      : ['#c2410c', '#be123c', '#b91c1c', '#a16207', '#0d9488', '#15803d', '#2563eb', '#7c3aed'];
    const expenseBreakdownPalette = isDark
      ? ['#5ab0ff', '#c77dff', '#5edb6e', '#ffb84d', '#4dd0e1', '#ff4d88', '#f3e37c', '#8dd3c7', '#f4a261', '#adb5bd']
      : ['#1e88e5', '#8e24aa', '#43a047', '#fb8c00', '#00acc1', '#d81b60', '#9c6f00', '#0f766e', '#c05621', '#546e7a'];
    const expenseColorOverrides = {
      'doublezero fees': isDark ? '#ff4d88' : '#d81b60',
      'contractor contractor': isDark ? '#5ab0ff' : '#1e88e5',
      'software notion': isDark ? '#5edb6e' : '#43a047',
      'hosting edgevana': isDark ? '#ffb84d' : '#fb8c00',
      'hosting latitude': isDark ? '#c77dff' : '#8e24aa',
      'hosting google cloud': isDark ? '#4dd0e1' : '#00acc1',
      'vote costs': isDark ? '#9aa5b1' : '#546e7a',
      'other': isDark ? '#adb5bd' : '#6b7280',
    };
    let uiUpdateTimer = null;

    function withUiTransition(work) {
      if (document.startViewTransition) {
        document.startViewTransition(work);
        return;
      }

      const layout = document.getElementById('content-layout');
      layout.classList.add('ui-updating');
      work();

      if (uiUpdateTimer) clearTimeout(uiUpdateTimer);
      uiUpdateTimer = setTimeout(() => {
        layout.classList.remove('ui-updating');
      }, 220);
    }

    function currentSolPrice() {
      const sp = solPrice();
      return Number.isFinite(sp) && sp > 0 ? sp : 150;
    }

    function usdToSol(usd) {
      return usd / currentSolPrice();
    }

    function eventValueInUnit(ev) {
      if (currentUnit === 'usd') return ev.amount_usd;
      return ev.amount_sol !== 0 ? ev.amount_sol : usdToSol(ev.amount_usd);
    }

    function eventSolValue(usd, sol) {
      return sol !== 0 ? sol : usdToSol(usd);
    }

    function formatEventValueForUnit(usd, sol, unit) {
      return unit === 'usd' ? formatUsd(usd) : formatSol(eventSolValue(usd, sol));
    }

    function parseIsoDate(dateStr) {
      const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateStr);
      if (!m) return null;
      const year = parseInt(m[1], 10);
      const month = parseInt(m[2], 10);
      const day = parseInt(m[3], 10);
      if (year < 1000 || month < 1 || month > 12 || day < 1 || day > 31) return null;
      return new Date(Date.UTC(year, month - 1, day));
    }

    function activeTimeline() {
      return currentViewMode === 'tax' ? TAX_TIMELINE : TIMELINE;
    }

    function latestTimelineDate(events) {
      let latest = null;
      for (const ev of events) {
        const d = parseIsoDate(ev.date);
        if (d && (!latest || d > latest)) latest = d;
      }
      if (latest) return latest;
      const now = new Date();
      return new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    }

    function latestEpochForEvents(events) {
      return events.reduce((max, ev) => (
        Number.isFinite(ev.epoch) && ev.epoch > max ? ev.epoch : max
      ), -1);
    }

    function getTypeGroupOptions() {
      return currentViewMode === 'tax' ? taxTypeGroupOptions : operatingTypeGroupOptions;
    }

    function getSubtypeMap() {
      return currentViewMode === 'tax' ? taxSubtypeMap : operatingSubtypeMap;
    }

    function taxClassForEvent(ev) {
      const expenseTypes = [
        'tax_expense_vote_fees',
        'tax_expense_doublezero',
        'tax_expense_hosting',
        'tax_expense_software',
        'tax_expense_contractor',
        'tax_expense_hardware',
        'tax_expense_other',
      ];
      if (ev.event_type === 'tax_revenue') return 'taxable_income';
      if (expenseTypes.includes(ev.event_type)) return 'deductible_expense';
      if (ev.event_type === 'tax_reimbursement') return 'reimbursement';
      if (ev.event_type === 'tax_return_capital') return 'non_taxable_transfer';
      return 'needs_review';
    }

    function taxClassLabel(ev) {
      const cls = taxClassForEvent(ev);
      if (cls === 'taxable_income') return 'Taxable income';
      if (cls === 'deductible_expense') return 'Deductible expense';
      if (cls === 'reimbursement') return 'Reimbursement';
      if (cls === 'non_taxable_transfer') return 'Non-taxable transfer';
      return 'Needs review';
    }

    function typeBadgeLabel(ev) {
      if (currentViewMode === 'tax') {
        const map = {
          tax_revenue: 'Taxable',
          tax_reimbursement: 'Reimb.',
          tax_return_capital: 'Capital',
          tax_expense_vote_fees: 'Vote Fee',
          tax_expense_doublezero: 'DZ Fee',
          tax_expense_hosting: 'Hosting',
          tax_expense_software: 'Software',
          tax_expense_contractor: 'Contractor',
          tax_expense_hardware: 'Hardware',
          tax_expense_other: 'Expense',
        };
        return map[ev.event_type] || 'Review';
      }

      const map = {
        commission: 'Commission',
        leader_fees: 'Leader',
        mev: 'MEV',
        bam: 'BAM',
        vote_cost: 'Vote Fee',
        doublezero: 'DZ Fee',
        expense: 'Expense',
        seeding: 'Seeding',
        withdrawal: 'Withdrawal',
        doublezero_payment: 'DZ Payment',
      };
      if (ev.event_type === 'expense') {
        const parts = String(ev.label || '').split('—').map(s => s.trim()).filter(Boolean);
        if (parts.length >= 2) return parts[1];
      }
      return map[ev.event_type] || 'Event';
    }

    function typeBadgeTone(ev) {
      if (currentViewMode === 'tax') {
        const cls = taxClassForEvent(ev);
        if (cls === 'taxable_income') return 'tone-income';
        if (cls === 'deductible_expense') return 'tone-expense';
        if (cls === 'needs_review') return 'tone-review';
        return 'tone-neutral';
      }

      if (!ev.is_pnl) return 'tone-neutral';
      if (ev.amount_usd > 0) return 'tone-income';
      if (ev.amount_usd < 0) return 'tone-expense';
      return 'tone-neutral';
    }

    function badgeAccentForEvent(ev) {
      if (ev.event_type === 'expense') {
        const parts = String(ev.label || '').split('—').map(s => s.trim().toLowerCase()).filter(Boolean);
        const category = parts.length >= 2 ? parts[1] : '';
        if (category.includes('hosting')) return 'var(--timeline-expense-hosting)';
        if (category.includes('software')) return 'var(--timeline-expense-software)';
        if (category.includes('contractor')) return 'var(--timeline-expense-contractor)';
        if (category.includes('hardware')) return 'var(--timeline-expense-hardware)';
        return 'var(--timeline-expense-other)';
      }

      if (ev.event_type.startsWith('tax_')) {
        const taxAccentMap = {
          tax_revenue: 'var(--timeline-tax-revenue)',
          tax_reimbursement: 'var(--timeline-tax-reimbursement)',
          tax_return_capital: 'var(--timeline-tax-return-capital)',
          tax_expense_vote_fees: 'var(--timeline-tax-expense-vote-fees)',
          tax_expense_doublezero: 'var(--timeline-tax-expense-doublezero)',
          tax_expense_hosting: 'var(--timeline-tax-expense-hosting)',
          tax_expense_software: 'var(--timeline-tax-expense-software)',
          tax_expense_contractor: 'var(--timeline-tax-expense-contractor)',
          tax_expense_hardware: 'var(--timeline-tax-expense-hardware)',
          tax_expense_other: 'var(--timeline-tax-expense-other)',
        };
        return taxAccentMap[ev.event_type] || 'var(--timeline-other)';
      }

      const accentMap = {
        commission: 'var(--timeline-commission)',
        leader_fees: 'var(--timeline-leader)',
        mev: 'var(--timeline-mev)',
        bam: 'var(--timeline-bam)',
        vote_cost: 'var(--timeline-vote)',
        doublezero: 'var(--timeline-doublezero)',
        seeding: 'var(--timeline-seeding)',
        withdrawal: 'var(--timeline-withdrawal)',
        doublezero_payment: 'var(--timeline-dz-payment)',
      };
      return accentMap[ev.event_type] || 'var(--timeline-other)';
    }

    function applyModeText() {
      if (currentViewMode === 'tax') {
        profitLabelEl.textContent = 'Net Tax Result';
        revenueLabelEl.textContent = 'Taxable Income';
        expensesLabelEl.textContent = 'Deductions';
        monthlyTitleEl.textContent = '─┤ Monthly Taxable vs Deductible ├─';
        incomeTitleEl.textContent = '─┤ Taxable Income Breakdown ├─';
        expenseTitleEl.textContent = '─┤ Deduction Breakdown ├─';
      } else {
        profitLabelEl.textContent = 'Net P/L';
        revenueLabelEl.textContent = 'Revenue';
        expensesLabelEl.textContent = 'Expenses';
        monthlyTitleEl.textContent = '─┤ Net Monthly Performance ├─';
        incomeTitleEl.textContent = '─┤ Income Breakdown ├─';
        expenseTitleEl.textContent = '─┤ Expense Breakdown ├─';
      }
    }

    function setViewMode(mode) {
      if (mode === currentViewMode) return;
      currentViewMode = mode;
      currentTypeGroup = mode === 'tax' ? 'tax_events' : 'all';
      currentSubtype = 'all';
      document.getElementById('btn-mode-operating').classList.toggle('active', mode === 'operating');
      document.getElementById('btn-mode-tax').classList.toggle('active', mode === 'tax');
      applyModeText();
      render({ animate: true, scrollToBottom: true });
    }

    function dateRangeStart(rangeId, endDate) {
      const end = new Date(endDate);
      if (rangeId === '30d') {
        const d = new Date(end);
        d.setUTCDate(d.getUTCDate() - 29);
        return d;
      }
      if (rangeId === '90d') {
        const d = new Date(end);
        d.setUTCDate(d.getUTCDate() - 89);
        return d;
      }
      return null;
    }

    function eventGroup(ev) {
      if (currentViewMode === 'tax') {
        const cls = taxClassForEvent(ev);
        if (cls === 'taxable_income' || cls === 'deductible_expense' || cls === 'reimbursement') return 'tax_events';
        return cls;
      }
      if (!ev.is_pnl) return 'non_pnl';
      if (ev.amount_usd > 0) return 'revenue';
      if (ev.amount_usd < 0) return 'expenses';
      if (operatingSubtypeMap.expenses.includes(ev.event_type)) return 'expenses';
      if (operatingSubtypeMap.revenue.includes(ev.event_type)) return 'revenue';
      return 'non_pnl';
    }

    function passesDateRange(ev) {
      if (currentDateRange === 'all') return true;
      const events = activeTimeline();
      const endDate = latestTimelineDate(events);

      if (currentDateRange === 'last_epoch') {
        const latestEpoch = latestEpochForEvents(events);
        if (latestEpoch < 0) return true;
        return ev.epoch === latestEpoch;
      }
      if (currentDateRange === '2025' || currentDateRange === '2026') return ev.date.startsWith(currentDateRange);
      const d = parseIsoDate(ev.date);
      if (!d) return false;
      const start = dateRangeStart(currentDateRange, endDate);
      return !!start && d >= start && d <= endDate;
    }

    function passesTypeFilter(ev) {
      const group = eventGroup(ev);
      if (currentTypeGroup !== 'all' && group !== currentTypeGroup) return false;
      if (currentSubtype !== 'all' && ev.event_type !== currentSubtype) return false;
      return true;
    }

    function getFilteredEvents() {
      return activeTimeline().filter(ev => passesDateRange(ev) && passesTypeFilter(ev));
    }

    function monthStartKey(dateStr) {
      const m = /^(\d{4})-(\d{2})-\d{2}$/.exec(dateStr);
      if (!m) return null;
      const year = parseInt(m[1], 10);
      const month = parseInt(m[2], 10);
      if (year < 1000 || month < 1 || month > 12) return null;
      return `${String(year).padStart(4, '0')}-${String(month).padStart(2, '0')}`;
    }

    function monthKeysForEvents(events) {
      let minYear = null;
      let minMonth = null;
      let maxYear = null;
      let maxMonth = null;

      for (const ev of events) {
        if (!ev.is_pnl) continue;
        const key = monthStartKey(ev.date);
        if (!key) continue;
        const [ys, ms] = key.split('-');
        const year = parseInt(ys, 10);
        const month = parseInt(ms, 10);

        if (minYear === null || year < minYear || (year === minYear && month < minMonth)) {
          minYear = year;
          minMonth = month;
        }
        if (maxYear === null || year > maxYear || (year === maxYear && month > maxMonth)) {
          maxYear = year;
          maxMonth = month;
        }
      }

      if (minYear === null) return [];

      const out = [];
      let y = minYear;
      let m = minMonth;
      while (y < maxYear || (y === maxYear && m <= maxMonth)) {
        out.push(`${String(y).padStart(4, '0')}-${String(m).padStart(2, '0')}`);
        m += 1;
        if (m > 12) {
          y += 1;
          m = 1;
        }
      }
      return out;
    }

    function hashString(s) {
      let h = 0;
      for (let i = 0; i < s.length; i++) {
        h = (h << 5) - h + s.charCodeAt(i);
        h |= 0;
      }
      return Math.abs(h);
    }

    function normalizeBreakdownKey(s) {
      return String(s || '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, ' ')
        .trim();
    }

    function colorForBreakdownKey(key) {
      if (chartColors[key]) return chartColors[key];
      const lower = key.toLowerCase();
      if (lower.includes('vote')) return chartColors.vote_cost;
      if (lower.includes('doublezero')) return chartColors.doublezero;
      if (lower.includes('expense')) return chartColors.expense;
      return breakdownPalette[hashString(key) % breakdownPalette.length];
    }

    function expenseColorForLabel(label) {
      const normalized = normalizeBreakdownKey(label);
      if (expenseColorOverrides[normalized]) return expenseColorOverrides[normalized];
      if (normalized.includes('doublezero')) return expenseColorOverrides['doublezero fees'];
      if (normalized.includes('contractor')) return expenseColorOverrides['contractor contractor'];
      if (normalized.includes('notion')) return expenseColorOverrides['software notion'];
      if (normalized.includes('edgevana')) return expenseColorOverrides['hosting edgevana'];
      if (normalized.includes('latitude')) return expenseColorOverrides['hosting latitude'];
      if (normalized.includes('google cloud')) return expenseColorOverrides['hosting google cloud'];
      if (normalized.includes('vote')) return expenseColorOverrides['vote costs'];
      return expenseBreakdownPalette[hashString(normalized) % expenseBreakdownPalette.length];
    }

    function expenseBreakdownKey(ev) {
      if (ev.event_type === 'expense') {
        const label = (ev.label || 'Expense').trim();
        const parts = label.split('—').map(s => s.trim()).filter(Boolean);
        if (parts.length === 2) {
          const [vendor, category] = parts;
          return `${category}: ${vendor}`;
        }
        return label;
      }
      if (ev.event_type === 'vote_cost') return 'Vote Costs';
      if (ev.event_type === 'doublezero') return 'DoubleZero Fees';
      return typeLabels[ev.event_type] || ev.label || ev.event_type;
    }

    function renderDashboard(events) {
      const dashEl = document.getElementById('dashboard-container');
      if (!events || !events.length) {
        dashEl.style.display = 'none';
        return;
      }
      dashEl.style.display = 'block';

      const monthKeys = monthKeysForEvents(events);
      if (!monthKeys.length) {
        dashEl.style.display = 'none';
        return;
      }

      const monthlyData = {};
      for (const month of monthKeys) {
        monthlyData[month] = { revenue: 0, expenses: 0, net: 0, month };
      }
      const incomeByType = {};
      const expenseByType = {};

      for (const ev of events) {
        if (!ev.is_pnl) continue;

        const month = monthStartKey(ev.date);
        if (!month || !monthlyData[month]) continue;

        const val = eventValueInUnit(ev);

        if (val > 0) {
          monthlyData[month].revenue += val;
          incomeByType[ev.event_type] = (incomeByType[ev.event_type] || 0) + val;
        } else if (val < 0) {
          monthlyData[month].expenses += Math.abs(val);
          const expenseKey = expenseBreakdownKey(ev);
          expenseByType[expenseKey] = (expenseByType[expenseKey] || 0) + Math.abs(val);
        }
        monthlyData[month].net += val;
      }

      const sortedMonths = monthKeys;
      const monthStarts = sortedMonths.map(m => `${m}-01`);
      const labels = monthStarts;

      const revData = sortedMonths.map(m => monthlyData[m].revenue);
      const expData = sortedMonths.map(m => -monthlyData[m].expenses);

      // --- PnL Bar Chart ---
      const pnlCtx = document.getElementById('chart-pnl').getContext('2d');
      if (pnlChartInstance) pnlChartInstance.destroy();

      pnlChartInstance = new Chart(pnlCtx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Revenue',
              data: revData,
              backgroundColor: chartGreen,
              borderRadius: 0,
              barPercentage: 0.6,
            },
            {
              label: 'Expenses',
              data: expData,
              backgroundColor: chartRed,
              borderRadius: 0,
              barPercentage: 0.6,
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { left: 8, right: 8, top: 4, bottom: 0 } },
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                title: function (ctxItems) {
                  const idx = ctxItems[0].dataIndex;
                  return monthStarts[idx];
                },
                label: function (ctx) {
                  const sym = currentUnit === 'usd' ? '$' : '';
                  const suf = currentUnit === 'usd' ? '' : ' SOL';
                  const val = Math.abs(ctx.raw);
                  return ctx.dataset.label + ': ' + sym + val.toLocaleString(undefined, { maximumFractionDigits: 2 }) + suf;
                }
              }
            }
          },
          scales: {
            x: {
              stacked: true,
              grid: { display: false },
              ticks: { autoSkip: true, maxRotation: 0, minRotation: 0 }
            },
            y: {
              stacked: true,
              border: { display: false },
              ticks: {
                padding: 6,
                callback: function (val) {
                  if (val === 0) return '0';
                  const abs = Math.abs(val);
                  if (currentUnit === 'usd') {
                    if (abs >= 1000) return '$' + (val / 1000).toFixed(0) + 'k';
                    return '$' + val;
                  } else {
                    if (abs >= 1000) return (val / 1000).toFixed(1) + 'k SOL';
                    return val + ' SOL';
                  }
                }
              }
            }
          }
        }
      });

      // --- Breakdown Charts config ---
      const donutOptions = {
        responsive: true, maintainAspectRatio: false, cutout: '70%',
        plugins: {
          legend: { position: 'bottom', labels: { boxWidth: 10, usePointStyle: true, font: { size: 10, family: 'monospace' } } },
          tooltip: {
            callbacks: {
              label: function (ctx) {
                const total = ctx.dataset.data.reduce((acc, n) => acc + n, 0);
                const val = ctx.raw;
                const pct = total > 0 ? (val / total) * 100 : 0;
                const sym = currentUnit === 'usd' ? '$' : '';
                const suf = currentUnit === 'usd' ? '' : ' SOL';
                return `${ctx.label}: ${sym}${val.toLocaleString(undefined, { maximumFractionDigits: 2 })}${suf} (${pct.toFixed(1)}%)`;
              }
            }
          }
        }
      };

      // --- Income Chart ---
      const incomeCtx = document.getElementById('chart-income').getContext('2d');
      if (incomeChartInstance) incomeChartInstance.destroy();

      const incKeys = Object.keys(incomeByType).sort((a, b) => incomeByType[b] - incomeByType[a]);
      if (incKeys.length > 0) {
        incomeChartInstance = new Chart(incomeCtx, {
          type: 'doughnut',
          data: {
            labels: incKeys.map(k => typeLabels[k] || k),
            datasets: [{
              data: incKeys.map(k => incomeByType[k]),
              backgroundColor: incKeys.map(k => colorForBreakdownKey(k)),
              borderWidth: 0,
              hoverOffset: 4
            }]
          },
          options: donutOptions
        });
      }

      // --- Expense Chart ---
      const expCtx = document.getElementById('chart-expenses').getContext('2d');
      if (expenseChartInstance) expenseChartInstance.destroy();

      const expenseEntries = Object.entries(expenseByType).sort((a, b) => b[1] - a[1]);
      const expenseSliceLimit = 8;
      const expRows = expenseEntries.length <= expenseSliceLimit
        ? expenseEntries
        : [
          ...expenseEntries.slice(0, expenseSliceLimit - 1),
          ['Other', expenseEntries.slice(expenseSliceLimit - 1).reduce((sum, entry) => sum + entry[1], 0)]
        ];

      if (expRows.length > 0) {
        expenseChartInstance = new Chart(expCtx, {
          type: 'doughnut',
          data: {
            labels: expRows.map(entry => entry[0]),
            datasets: [{
              data: expRows.map(entry => entry[1]),
              backgroundColor: expRows.map(entry => expenseColorForLabel(entry[0])),
              borderWidth: 0,
              hoverOffset: 4
            }]
          },
          options: donutOptions
        });
      }
    }


    // ── Unit state ──────────────────────────────────────────────────────────────
    let currentUnit = 'usd';

    function setUnit(unit) {
      if (unit === currentUnit) return;
      withUiTransition(() => {
        if (rafId) { cancelAnimationFrame(rafId); rafId = null; }

        currentUnit = unit;
        document.getElementById('btn-usd').classList.toggle('active', unit === 'usd');
        document.getElementById('btn-sol').classList.toggle('active', unit === 'sol');

        document.querySelectorAll('.ev-sol').forEach(el => {
          const usd = parseFloat(el.dataset.usd || '0');
          const sol = parseFloat(el.dataset.sol || '0');
          el.textContent = formatSol(eventSolValue(usd, sol));
          el.style.display = unit === 'sol' ? '' : 'none';
        });
        document.querySelectorAll('.ev-usd').forEach(el => {
          const usd = parseFloat(el.dataset.usd || '0');
          el.textContent = formatUsd(usd);
        });

        document.querySelectorAll('.month-sep-net').forEach(el => {
          const netUsd = parseFloat(el.dataset.netUsd);
          el.textContent = (unit === 'usd' ? formatUsd(netUsd) : formatSol(usdToSol(netUsd))) + ' net';
          el.className = 'month-sep-net ' + valueSignClass(netUsd);
        });

        renderDashboard(currentRenderedEvents);
        updateHeaderDisplay(targetProfit, targetRevenue, targetExpenses, true);
      });
    }

    // ── Formatting helpers ──────────────────────────────────────────────────────
    function formatUsd(n) {
      if (n === 0) return '$0';
      const abs = Math.abs(n);
      const str = abs >= 1000
        ? '$' + Math.round(abs).toLocaleString()
        : '$' + abs.toFixed(2);
      return n < 0 ? '-' + str : str;
    }

    function formatSol(n) {
      if (n === 0) return '0 SOL';
      const abs = Math.abs(n);
      const str = abs.toFixed(abs < 0.01 ? 6 : abs < 1 ? 4 : 3) + ' SOL';
      return n < 0 ? '-' + str : str;
    }

    function formatAmount(usd, sol) {
      return currentUnit === 'usd' ? formatUsd(usd) : formatSol(sol);
    }

    function valueSignClass(v) {
      if (v > 0) return 'positive';
      if (v < 0) return 'negative';
      return 'neutral';
    }

    function shortDateLabel(dateStr) {
      const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateStr);
      if (!m) return dateStr;
      return `${m[2]}-${m[3]}`;
    }

    function usingPanelScroll() {
      if (!timelinePanelEl) return false;
      const style = getComputedStyle(timelinePanelEl);
      return style.overflowY !== 'visible' && style.overflowY !== 'clip';
    }

    function timelineAnchorViewportY() {
      if (usingPanelScroll()) return timelinePanelEl.getBoundingClientRect().top + 8;
      return (document.getElementById('header')?.getBoundingClientRect().bottom || 0) + 8;
    }

    function scrollToTimelineTop(smooth) {
      if (usingPanelScroll()) {
        timelinePanelEl.scrollTo({ top: 0, left: 0, behavior: smooth ? 'smooth' : 'auto' });
      } else {
        window.scrollTo({ top: 0, left: 0, behavior: smooth ? 'smooth' : 'auto' });
      }
    }

    function scrollTimelineToBottom() {
      if (usingPanelScroll()) {
        timelinePanelEl.scrollTop = timelinePanelEl.scrollHeight;
      } else {
        window.scrollTo(0, document.body.scrollHeight);
      }
    }

    // ── Recent SOL price estimate ────────────────────────────────────────────────
    function solPrice() {
      const candidates = [];
      for (let i = TIMELINE.length - 1; i >= 0 && candidates.length < 20; i--) {
        const e = TIMELINE[i];
        if (e.amount_sol !== 0) {
          const p = Math.abs(e.amount_usd / e.amount_sol);
          if (p > 1) candidates.push(p);
        }
      }
      if (!candidates.length) return 150;
      candidates.sort((a, b) => a - b);
      return candidates[Math.floor(candidates.length / 2)];
    }

    // ── Header filters ─────────────────────────────────────────────────────────
    function buildDateRangeTabs() {
      while (dateRangeTabsEl.firstChild) dateRangeTabsEl.removeChild(dateRangeTabsEl.firstChild);
      for (const range of dateRangeOptions) {
        const btn = document.createElement('button');
        btn.className = 'filter-btn' + (currentDateRange === range.id ? ' active' : '');
        btn.textContent = range.label;
        btn.onclick = () => {
          currentDateRange = range.id;
          render({ animate: true, scrollToBottom: true });
        };
        dateRangeTabsEl.appendChild(btn);
      }
    }

    function buildTypeFilters() {
      while (typeGroupTabsEl.firstChild) typeGroupTabsEl.removeChild(typeGroupTabsEl.firstChild);
      while (typeSubTabsEl.firstChild) typeSubTabsEl.removeChild(typeSubTabsEl.firstChild);

      for (const group of getTypeGroupOptions()) {
        const btn = document.createElement('button');
        btn.className = 'filter-btn' + (currentTypeGroup === group.id ? ' active' : '');
        btn.textContent = group.label;
        btn.onclick = () => {
          currentTypeGroup = group.id;
          currentSubtype = 'all';
          render({ animate: true, scrollToBottom: true });
        };
        typeGroupTabsEl.appendChild(btn);
      }

      if (currentTypeGroup === 'all') return;

      const allSub = document.createElement('button');
      allSub.className = 'filter-btn' + (currentSubtype === 'all' ? ' active' : '');
      allSub.textContent = 'All';
      allSub.onclick = () => {
        currentSubtype = 'all';
        render({ animate: true, scrollToBottom: true });
      };
      typeSubTabsEl.appendChild(allSub);

      const subtypes = getSubtypeMap()[currentTypeGroup] || [];
      for (const subtype of subtypes) {
        const btn = document.createElement('button');
        btn.className = 'filter-btn' + (currentSubtype === subtype ? ' active' : '');
        btn.textContent = typeLabels[subtype] || subtype;
        btn.onclick = () => {
          currentSubtype = subtype;
          render({ animate: true, scrollToBottom: true });
        };
        typeSubTabsEl.appendChild(btn);
      }
    }

    // ── Render timeline ─────────────────────────────────────────────────────────
    let allRows = [];

    function render({ scrollToBottom = false, animate = false } = {}) {
      if (animate) {
        withUiTransition(() => render({ scrollToBottom, animate: false }));
        return;
      }

      const filteredEvents = getFilteredEvents();

      currentRenderedEvents = filteredEvents;
      applyModeText();
      renderDashboard(currentRenderedEvents);
      buildDateRangeTabs();
      buildTypeFilters();
      syncStickyOffsets();

      if (!scrollToBottom) {
        scrollToTimelineTop(true);
      }
      const events = filteredEvents;

      const container = document.getElementById('timeline');
      while (container.firstChild) container.removeChild(container.firstChild);
      anchorIdx = null;
      allRows = [];

      if (events.length === 0) {
        const msg = document.createElement('div');
        msg.style.cssText = 'text-align:center;color:var(--ink-light);padding:60px 0;font-size:14px';
        msg.textContent = 'No events found for the selected filters.';
        container.appendChild(msg);
        setHeaderInstant(0, 0, 0);
        return;
      }

      const byMonth = new Map();
      for (const ev of events) {
        const mo = ev.date.slice(0, 7);
        if (!byMonth.has(mo)) byMonth.set(mo, []);
        byMonth.get(mo).push(ev);
      }

      for (const [mo, evs] of byMonth) {
        container.appendChild(buildMonthSep(mo, evs));
        for (const ev of evs) {
          const row = buildRow(ev);
          container.appendChild(row);
          allRows.push(row);
        }
      }

      let pProfit = 0, pRevenue = 0, pExpenses = 0;
      for (let i = 0; i < events.length; i++) {
        const ev = events[i];
        if (ev.is_pnl) {
          if (ev.amount_usd >= 0) pRevenue += ev.amount_usd;
          else pExpenses += Math.abs(ev.amount_usd);
          pProfit += ev.amount_usd;
        }
        allRows[i].dataset.profit = pProfit.toFixed(2);
        allRows[i].dataset.revenue = pRevenue.toFixed(2);
        allRows[i].dataset.expenses = pExpenses.toFixed(2);
      }

      const lastRow = allRows[allRows.length - 1];
      const seedP = parseFloat(lastRow.dataset.profit);
      const seedR = parseFloat(lastRow.dataset.revenue);
      const seedE = parseFloat(lastRow.dataset.expenses);
      setHeaderInstant(seedP, seedR, seedE);
      targetProfit = seedP;
      targetRevenue = seedR;
      targetExpenses = seedE;

      if (scrollToBottom) {
        anchorIdx = null;
        scrollTimelineToBottom();
        applyAnchorFromViewport(true);
      } else {
        applyAnchorFromViewport(true);
      }
    }

    function monthLabel(mo) {
      const [y, m] = mo.split('-');
      const months = ['January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'];
      return months[parseInt(m, 10) - 1] + ' ' + y;
    }

    function buildMonthSep(mo, evs) {
      let netUsd = 0;
      for (const ev of evs) { if (ev.is_pnl) netUsd += ev.amount_usd; }

      const div = document.createElement('div');
      div.className = 'month-sep';
      div.dataset.month = mo;

      const line1 = document.createElement('div');
      line1.className = 'month-sep-line';

      const lbl = document.createElement('span');
      lbl.className = 'month-sep-label';
      lbl.textContent = monthLabel(mo);

      const netEl = document.createElement('span');
      netEl.className = 'month-sep-net ' + valueSignClass(netUsd);
      netEl.dataset.netUsd = netUsd;
      netEl.textContent = (currentUnit === 'usd' ? formatUsd(netUsd) : formatSol(usdToSol(netUsd))) + ' net';

      const line2 = document.createElement('div');
      line2.className = 'month-sep-line';

      div.appendChild(line1);
      div.appendChild(lbl);
      div.appendChild(netEl);
      div.appendChild(line2);
      return div;
    }

    function rowClass(ev) {
      if (!ev.is_pnl) return 'ev-neutral';
      if (ev.amount_usd > 0) return 'ev-income';
      if (ev.amount_usd < 0) return 'ev-expense';
      return 'ev-neutral';
    }

    function buildRow(ev) {
      const div = document.createElement('div');
      div.className = 'event-row ' + rowClass(ev);
      div.dataset.profit = ev.cumulative_profit_usd.toFixed(2);
      div.dataset.revenue = ev.cumulative_revenue_usd.toFixed(2);
      div.dataset.expenses = ev.cumulative_expenses_usd.toFixed(2);

      const dateEl = document.createElement('span');
      dateEl.className = 'ev-date';
      dateEl.textContent = shortDateLabel(ev.date);

      const labelDiv = document.createElement('div');
      labelDiv.className = 'ev-label';
      const mainWrapEl = document.createElement('div');
      mainWrapEl.className = 'ev-label-main-wrap';
      const mainEl = document.createElement('span');
      mainEl.className = 'ev-label-main';
      mainEl.textContent = ev.label;
      const badgeEl = document.createElement('span');
      badgeEl.className = 'type-badge ' + typeBadgeTone(ev);
      badgeEl.dataset.type = ev.event_type;
      badgeEl.style.setProperty('--type-accent', badgeAccentForEvent(ev));
      badgeEl.textContent = typeBadgeLabel(ev);
      mainWrapEl.appendChild(badgeEl);
      mainWrapEl.appendChild(mainEl);
      labelDiv.appendChild(mainWrapEl);
      const subLabelText = currentViewMode === 'tax'
        ? [taxClassLabel(ev), ev.sublabel].filter(Boolean).join(' · ')
        : ev.sublabel;
      if (subLabelText) {
        const subEl = document.createElement('div');
        subEl.className = 'ev-label-sub';
        subEl.textContent = subLabelText;
        labelDiv.appendChild(subEl);
      }

      const solEl = document.createElement('span');
      solEl.className = 'ev-sol';
      solEl.dataset.usd = ev.amount_usd;
      solEl.dataset.sol = ev.amount_sol;
      solEl.textContent = formatSol(eventSolValue(ev.amount_usd, ev.amount_sol));
      solEl.style.display = currentUnit === 'sol' ? '' : 'none';

      const usdEl = document.createElement('span');
      usdEl.className = 'ev-usd';
      usdEl.dataset.sol = ev.amount_sol;
      usdEl.dataset.usd = ev.amount_usd;
      usdEl.textContent = formatUsd(ev.amount_usd);

      div.appendChild(dateEl);
      div.appendChild(labelDiv);
      div.appendChild(solEl);
      div.appendChild(usdEl);
      return div;
    }

    // ── Sticky header rewind ────────────────────────────────────────────────────
    let targetProfit = 0;
    let targetRevenue = 0;
    let targetExpenses = 0;
    let displayProfit = 0;
    let displayRevenue = 0;
    let displayExpenses = 0;
    let rafId = null;

    function syncStickyOffsets() {
      const header = document.getElementById('header');
      const headerH = header ? header.offsetHeight : 0;
      document.documentElement.style.setProperty('--header-offset', `${headerH}px`);
    }

    function lastRowAtOrAbove(y) {
      let lo = 0, hi = allRows.length - 1, found = null;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        const top = allRows[mid].getBoundingClientRect().top;
        if (top <= y) {
          found = mid;
          lo = mid + 1;
        } else {
          hi = mid - 1;
        }
      }
      return found;
    }

    function firstVisibleRowInPanel() {
      const panelTop = timelinePanelEl.getBoundingClientRect().top;
      let lo = 0, hi = allRows.length - 1, found = null;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        const bottom = allRows[mid].getBoundingClientRect().bottom;
        if (bottom >= panelTop + 1) {
          found = mid;
          hi = mid - 1;
        } else {
          lo = mid + 1;
        }
      }
      return found;
    }

    function lastVisibleRowInPanel() {
      const panelBottom = timelinePanelEl.getBoundingClientRect().bottom;
      let lo = 0, hi = allRows.length - 1, found = null;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        const top = allRows[mid].getBoundingClientRect().top;
        if (top <= panelBottom - 1) {
          found = mid;
          lo = mid + 1;
        } else {
          hi = mid - 1;
        }
      }
      return found;
    }

    function findAnchorRow() {
      if (!allRows.length) return null;

      if (usingPanelScroll()) {
        const panel = timelinePanelEl;
        const panelRect = panel.getBoundingClientRect();
        const panelTop = panelRect.top;
        const maxTop = Math.max(0, panel.scrollHeight - panel.clientHeight);
        const overflow = Math.max(0, maxTop - panel.scrollTop);

        // If the panel cannot scroll, default to the latest row so header
        // values reflect full-period totals for the current filter.
        if (maxTop <= 1) return allRows.length - 1;

        if (panel.scrollTop <= 1) return 0;
        if (maxTop > 0 && panel.scrollTop >= maxTop - 1) return allRows.length - 1;

        const baseY = panelTop + 8;
        const tailRange = Math.max(120, panel.clientHeight - 40);
        const tailProgress = overflow < tailRange ? (1 - (overflow / tailRange)) : 0;
        const anchorY = baseY + tailProgress * Math.max(0, panel.clientHeight - 36);

        let idx = lastRowAtOrAbove(anchorY);
        if (idx === null) idx = 0;

        const firstVisible = firstVisibleRowInPanel();
        if (firstVisible !== null && idx < firstVisible) idx = firstVisible;
        const lastVisible = lastVisibleRowInPanel();
        if (lastVisible !== null && idx > lastVisible) idx = lastVisible;
        return idx;
      }

      if (window.scrollY <= 1) return 0;
      const anchorY = timelineAnchorViewportY();
      const idx = lastRowAtOrAbove(anchorY);
      return idx === null ? 0 : idx;
    }

    function applyAnchorFromViewport(instant) {
      const idx = findAnchorRow();
      if (idx === null) return;
      setAnchor(idx);
      const row = allRows[idx];
      updateHeaderDisplay(
        parseFloat(row.dataset.profit),
        parseFloat(row.dataset.revenue),
        parseFloat(row.dataset.expenses),
        !!instant
      );
    }

    function updateHeaderDisplay(profit, revenue, expenses, instant) {
      if (instant) {
        displayProfit = profit; displayRevenue = revenue; displayExpenses = expenses;
        paintHeader();
        return;
      }
      targetProfit = profit;
      targetRevenue = revenue;
      targetExpenses = expenses;
      if (!rafId) rafId = requestAnimationFrame(animateHeader);
    }

    function animateHeader() {
      rafId = null;
      const LERP = 0.22;
      displayProfit += (targetProfit - displayProfit) * LERP;
      displayRevenue += (targetRevenue - displayRevenue) * LERP;
      displayExpenses += (targetExpenses - displayExpenses) * LERP;
      paintHeader();

      const dx = Math.abs(targetProfit - displayProfit)
        + Math.abs(targetRevenue - displayRevenue)
        + Math.abs(targetExpenses - displayExpenses);
      if (dx > 0.5) {
        rafId = requestAnimationFrame(animateHeader);
      } else {
        displayProfit = targetProfit;
        displayRevenue = targetRevenue;
        displayExpenses = targetExpenses;
        paintHeader();
      }
    }

    function paintHeader() {
      if (currentUnit === 'usd') {
        profitEl.textContent = formatUsd(displayProfit);
        revenueEl.textContent = formatUsd(displayRevenue);
        expensesEl.textContent = formatUsd(displayExpenses);
      } else {
        const sp = currentSolPrice();
        profitEl.textContent = formatSol(displayProfit / sp);
        revenueEl.textContent = formatSol(displayRevenue / sp);
        expensesEl.textContent = formatSol(displayExpenses / sp);
      }

      profitEl.className = 'stat-value ' + (displayProfit >= 0 ? 'positive' : 'negative');
      revenueEl.className = 'stat-value positive';
      expensesEl.className = 'stat-value negative';
    }

    function setHeaderInstant(profit, revenue, expenses) {
      targetProfit = profit; targetRevenue = revenue; targetExpenses = expenses;
      displayProfit = profit; displayRevenue = revenue; displayExpenses = expenses;
      paintHeader();
    }

    // ── Scroll handler ───────────────────────────────────────────────────────────
    let scrollTicking = false;
    let anchorIdx = null;

    function setAnchor(idx) {
      const prevRow = anchorIdx !== null ? allRows[anchorIdx] : null;
      if (idx === anchorIdx && prevRow && prevRow.classList.contains('row-anchor')) return;
      if (prevRow) {
        prevRow.classList.remove('row-anchor');
      }
      anchorIdx = idx;
      if (idx !== null && allRows[idx]) {
        allRows[idx].classList.add('row-anchor');
      }
    }

    function scheduleAnchorUpdate() {
      if (scrollTicking) return;
      scrollTicking = true;
      requestAnimationFrame(() => {
        scrollTicking = false;
        applyAnchorFromViewport(false);
      });
    }

    window.addEventListener('scroll', scheduleAnchorUpdate, { passive: true });
    if (timelinePanelEl) {
      timelinePanelEl.addEventListener('scroll', scheduleAnchorUpdate, { passive: true });
    }

    let resizeDebounce = null;
    window.addEventListener('resize', () => {
      if (resizeDebounce) clearTimeout(resizeDebounce);
      resizeDebounce = setTimeout(() => {
        syncStickyOffsets();
        renderDashboard(currentRenderedEvents);
        applyAnchorFromViewport(true);
      }, 120);
    }, { passive: true });

    // ── Init ────────────────────────────────────────────────────────────────────
    syncStickyOffsets();
    render({ scrollToBottom: true });
    requestAnimationFrame(() => {
      scrollTimelineToBottom();
      applyAnchorFromViewport(true);
    });
  </script>
</body>

</html>
