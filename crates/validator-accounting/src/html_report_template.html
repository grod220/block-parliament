<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Block Parliament · Validator Financials</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg: #09090b;
      --surface: rgba(24, 24, 27, 0.6);
      --border: rgba(63, 63, 70, 0.4);
      --text: #f4f4f5;
      --muted: #a1a1aa;
      --green: #10b981;
      --red: #ef4444;
      --neutral: #71717a;
      --accent: #3b82f6;
      --header-h: 72px;
      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    }

    body {
      background: var(--bg);
      background-image: radial-gradient(circle at 15% 50%, rgba(59, 130, 246, 0.08), transparent 25%),
        radial-gradient(circle at 85% 30%, rgba(16, 185, 129, 0.08), transparent 25%);
      background-attachment: fixed;
      color: var(--text);
      font-family: var(--font-sans);
      font-size: 14px;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }

    /* ── Sticky header ── */
    #header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: rgba(9, 9, 11, 0.8);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-bottom: 1px solid var(--border);
      padding: 12px 20px 10px;
      /* min-height so tabs never get clipped on narrow viewports */
      min-height: var(--header-h);
    }

    .header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .header-title {
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.08em;
      color: var(--muted);
      text-transform: uppercase;
    }

    .unit-toggle {
      display: flex;
      gap: 4px;
    }

    .unit-btn {
      background: none;
      border: 1px solid var(--border);
      color: var(--muted);
      padding: 2px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.15s;
    }

    .unit-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .stats-row {
      display: flex;
      gap: 12px;
      margin-bottom: 12px;
    }

    .stat-card {
      flex: 1;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      backdrop-filter: blur(8px);
    }

    .stat-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
      margin-bottom: 2px;
    }

    .stat-value {
      font-size: 22px;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
      letter-spacing: -0.02em;
      transition: color 0.2s;
      margin-top: 4px;
    }

    .stat-value.positive {
      color: var(--green);
    }

    .stat-value.negative {
      color: var(--red);
    }

    .stat-value.neutral {
      color: var(--text);
    }

    .period-tabs {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .period-btn {
      background: none;
      border: 1px solid var(--border);
      color: var(--muted);
      padding: 2px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.15s;
    }

    /* Hover: accent outline only */
    .period-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Active: filled — visually distinct from hover */
    .period-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    /* ── Timeline ── */
    #content-layout {
      max-width: 1600px;
      margin: 20px auto 0;
      padding: 0 20px;
      display: grid;
      grid-template-columns: minmax(420px, 48%) minmax(520px, 52%);
      gap: 20px;
      align-items: start;
    }

    #timeline {
      max-width: none;
      margin: 0;
      padding: 0 0 80px;
      min-width: 0;
    }

    .month-sep {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 28px 0 6px;
      padding-top: 4px;
    }

    .month-sep-line {
      flex: 1;
      height: 1px;
      background: var(--border);
    }

    .month-sep-label {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--muted);
      white-space: nowrap;
    }

    .month-sep-net {
      font-size: 11px;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    .month-sep-net.positive {
      color: var(--green);
    }

    .month-sep-net.negative {
      color: var(--red);
    }

    /* ── Event rows ── */
    .event-row {
      display: grid;
      grid-template-columns: 88px 20px 1fr auto auto;
      /* start-alignment so multi-line labels don't float the date/amount up */
      align-items: start;
      gap: 0 10px;
      padding: 5px 8px;
      border-radius: 6px;
      transition: background 0.1s;
    }

    .event-row:hover {
      background: var(--surface);
    }

    /* Row whose cumulative totals are currently shown in the sticky header */
    .row-anchor {
      background: var(--surface);
      box-shadow: inset 2px 0 0 var(--accent);
    }

    .ev-date {
      font-size: 12px;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
      padding-top: 1px;
    }

    .ev-dot {
      text-align: center;
      font-size: 10px;
      padding-top: 3px;
    }

    /* Per-category dot colors */
    .ev-dot[data-type="commission"] {
      color: #f59e0b;
    }

    /* amber  */
    .ev-dot[data-type="leader_fees"] {
      color: #60a5fa;
    }

    /* sky    */
    .ev-dot[data-type="mev"] {
      color: #a78bfa;
    }

    /* violet */
    .ev-dot[data-type="bam"] {
      color: #22d3ee;
    }

    /* cyan   */
    .ev-dot[data-type="vote_cost"] {
      color: #fb923c;
    }

    /* orange */
    .ev-dot[data-type="doublezero"] {
      color: #f43f5e;
    }

    /* rose   */
    .ev-dot[data-type="expense"] {
      color: #f87171;
    }

    /* red    */
    .ev-dot[data-type="seeding"] {
      color: #34d399;
    }

    /* emerald*/
    .ev-dot[data-type="withdrawal"] {
      color: #94a3b8;
    }

    /* slate  */
    .ev-dot[data-type="doublezero_payment"] {
      color: #818cf8;
    }

    /* indigo */

    .ev-label {
      min-width: 0;
    }

    .ev-label-main {
      font-size: 13px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .ev-label-sub {
      font-size: 11px;
      color: var(--muted);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .ev-sol {
      text-align: right;
      font-size: 12px;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
      padding-top: 1px;
    }

    .ev-usd {
      text-align: right;
      font-size: 13px;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
      min-width: 80px;
      padding-top: 1px;
    }

    .ev-income .ev-sol,
    .ev-income .ev-usd {
      color: var(--green);
    }

    .ev-expense .ev-sol,
    .ev-expense .ev-usd {
      color: var(--red);
    }

    .ev-neutral .ev-sol,
    .ev-neutral .ev-usd {
      color: var(--neutral);
    }

    /* ── Dashboard ── */
    #dashboard-container {
      margin: 0;
      padding: 0;
      position: sticky;
      top: calc(var(--header-h) + 14px);
    }

    .dashboard-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    .dashboard-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(8px);
      display: flex;
      flex-direction: column;
    }

    .dashboard-card-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--muted);
      margin-bottom: 16px;
    }

    .dashboard-chart-tall {
      height: 220px;
      position: relative;
    }

    .dashboard-chart {
      flex: 1;
      position: relative;
      min-height: 180px;
    }

    @media (max-width: 1200px) {
      #content-layout {
        grid-template-columns: 1fr;
        gap: 14px;
      }

      #dashboard-container {
        position: static;
      }

      .dashboard-grid {
        grid-template-columns: 1fr 1fr;
      }

      .dashboard-card-main {
        grid-column: 1 / -1;
      }
    }

    @media (max-width: 700px) {
      :root {
        --header-h: 104px;
      }

      #header {
        padding: 10px 12px 8px;
      }

      #content-layout {
        margin-top: 12px;
        padding: 0 12px;
      }

      #dashboard-container {
        margin: 0;
        padding: 0;
      }

      .dashboard-grid {
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .stats-row {
        gap: 8px;
      }

      .stat-card {
        padding: 8px 10px;
      }

      .stat-value {
        font-size: 18px;
      }

      .dashboard-card {
        padding: 14px;
      }

      .dashboard-chart-tall {
        height: 180px;
      }

      .dashboard-chart {
        min-height: 150px;
      }

      #timeline {
        padding: 0 0 72px;
      }
    }
  </style>
</head>

<body>

  <div id="header">
    <div class="header-top">
      <span class="header-title">Block Parliament · Validator Financials</span>
      <div class="unit-toggle">
        <button class="unit-btn active" id="btn-usd" onclick="setUnit('usd')">USD</button>
        <button class="unit-btn" id="btn-sol" onclick="setUnit('sol')">SOL</button>
      </div>
    </div>

    <div class="period-tabs" id="period-tabs">
      <!-- injected by JS -->
    </div>
  </div>

  <div id="content-layout">
    <div id="dashboard-container">
      <div class="stats-row">
        <div class="stat-card">
          <div class="stat-label">Net P/L</div>
          <div class="stat-value" id="stat-profit">$0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Revenue</div>
          <div class="stat-value" id="stat-revenue">$0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Expenses</div>
          <div class="stat-value" id="stat-expenses">$0</div>
        </div>
      </div>

      <div class="dashboard-grid">
        <!-- Main PnL Chart -->
        <div class="dashboard-card dashboard-card-main">
          <div class="dashboard-card-title">Net Monthly Performance</div>
          <div class="dashboard-chart-tall"><canvas id="chart-pnl"></canvas></div>
        </div>

        <!-- Revenue Breakdown -->
        <div class="dashboard-card">
          <div class="dashboard-card-title">Income Breakdown</div>
          <div class="dashboard-chart"><canvas id="chart-income"></canvas></div>
        </div>

        <!-- Expense Breakdown -->
        <div class="dashboard-card">
          <div class="dashboard-card-title">Expense Breakdown (by line item)</div>
          <div class="dashboard-chart"><canvas id="chart-expenses"></canvas></div>
        </div>
      </div>
    </div>

    <div id="timeline"></div>
  </div>

  <script>
    const TIMELINE = __TIMELINE_JSON__;

    // ── Cached DOM refs ──────────────────────────────────────────────────────────
    // Queried once at startup — these elements never move.
    const profitEl = document.getElementById('stat-profit');
    const revenueEl = document.getElementById('stat-revenue');
    const expensesEl = document.getElementById('stat-expenses');

    // ── Chart.js Global Config ───────────────────────────────────────────────────
    Chart.defaults.color = '#a1a1aa';
    Chart.defaults.font.family = "'Inter', sans-serif";
    Chart.defaults.scale.grid.color = 'rgba(63, 63, 70, 0.4)';
    Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(24, 24, 27, 0.9)';
    Chart.defaults.plugins.tooltip.titleColor = '#f4f4f5';
    Chart.defaults.plugins.tooltip.bodyColor = '#a1a1aa';
    Chart.defaults.plugins.tooltip.padding = 10;
    Chart.defaults.plugins.tooltip.cornerRadius = 8;
    Chart.defaults.plugins.tooltip.displayColors = true;

    const chartColors = {
      commission: '#f59e0b',
      leader_fees: '#60a5fa',
      mev: '#a78bfa',
      bam: '#22d3ee',
      vote_cost: '#fb923c', // expenses are negative in data, we absolute them
      expense: '#ef4444',
      doublezero: '#f43f5e',
      other: '#52525b'
    };

    const typeLabels = {
      commission: 'Commission',
      leader_fees: 'Leader Fees',
      mev: 'MEV Tips',
      bam: 'BAM',
      vote_cost: 'Vote Costs',
      expense: 'Expenses',
      doublezero: 'DoubleZero Fees'
    };

    let pnlChartInstance = null;
    let incomeChartInstance = null;
    let expenseChartInstance = null;
    const breakdownPalette = ['#fb923c', '#f43f5e', '#ef4444', '#eab308', '#14b8a6', '#22c55e', '#60a5fa', '#a78bfa'];

    function currentSolPrice() {
      const sp = solPrice();
      return Number.isFinite(sp) && sp > 0 ? sp : 150;
    }

    function usdToSol(usd) {
      return usd / currentSolPrice();
    }

    function eventValueInUnit(ev) {
      if (currentUnit === 'usd') return ev.amount_usd;
      return ev.amount_sol !== 0 ? ev.amount_sol : usdToSol(ev.amount_usd);
    }

    function monthStartKey(dateStr) {
      const m = /^(\d{4})-(\d{2})-\d{2}$/.exec(dateStr);
      if (!m) return null;
      const year = parseInt(m[1], 10);
      const month = parseInt(m[2], 10);
      if (year < 1000 || month < 1 || month > 12) return null;
      return `${String(year).padStart(4, '0')}-${String(month).padStart(2, '0')}`;
    }

    function monthKeysForEvents(events) {
      let minYear = null;
      let minMonth = null;
      let maxYear = null;
      let maxMonth = null;

      for (const ev of events) {
        if (!ev.is_pnl) continue;
        const key = monthStartKey(ev.date);
        if (!key) continue;
        const [ys, ms] = key.split('-');
        const year = parseInt(ys, 10);
        const month = parseInt(ms, 10);

        if (minYear === null || year < minYear || (year === minYear && month < minMonth)) {
          minYear = year;
          minMonth = month;
        }
        if (maxYear === null || year > maxYear || (year === maxYear && month > maxMonth)) {
          maxYear = year;
          maxMonth = month;
        }
      }

      if (minYear === null) return [];

      const out = [];
      let y = minYear;
      let m = minMonth;
      while (y < maxYear || (y === maxYear && m <= maxMonth)) {
        out.push(`${String(y).padStart(4, '0')}-${String(m).padStart(2, '0')}`);
        m += 1;
        if (m > 12) {
          y += 1;
          m = 1;
        }
      }
      return out;
    }

    function hashString(s) {
      let h = 0;
      for (let i = 0; i < s.length; i++) {
        h = (h << 5) - h + s.charCodeAt(i);
        h |= 0;
      }
      return Math.abs(h);
    }

    function colorForBreakdownKey(key) {
      if (chartColors[key]) return chartColors[key];
      const lower = key.toLowerCase();
      if (lower.includes('vote')) return chartColors.vote_cost;
      if (lower.includes('doublezero')) return chartColors.doublezero;
      if (lower.includes('expense')) return chartColors.expense;
      return breakdownPalette[hashString(key) % breakdownPalette.length];
    }

    function expenseBreakdownKey(ev) {
      if (ev.event_type === 'expense') {
        const label = (ev.label || 'Expense').trim();
        const parts = label.split('—').map(s => s.trim()).filter(Boolean);
        if (parts.length === 2) {
          const [vendor, category] = parts;
          return `${category}: ${vendor}`;
        }
        return label;
      }
      if (ev.event_type === 'vote_cost') return 'Vote Costs';
      if (ev.event_type === 'doublezero') return 'DoubleZero Fees';
      return typeLabels[ev.event_type] || ev.label || ev.event_type;
    }

    function renderDashboard(events) {
      const dashEl = document.getElementById('dashboard-container');
      if (!events || events.length < 5) {
        dashEl.style.display = 'none';
        return;
      }
      dashEl.style.display = 'block';

      const monthKeys = monthKeysForEvents(events);
      if (!monthKeys.length) {
        dashEl.style.display = 'none';
        return;
      }

      const monthlyData = {};
      for (const month of monthKeys) {
        monthlyData[month] = { revenue: 0, expenses: 0, net: 0, month };
      }
      const incomeByType = {};
      const expenseByType = {};

      for (const ev of events) {
        if (!ev.is_pnl) continue;

        const month = monthStartKey(ev.date);
        if (!month || !monthlyData[month]) continue;

        const val = eventValueInUnit(ev);

        if (val > 0) {
          monthlyData[month].revenue += val;
          incomeByType[ev.event_type] = (incomeByType[ev.event_type] || 0) + val;
        } else if (val < 0) {
          monthlyData[month].expenses += Math.abs(val);
          const expenseKey = expenseBreakdownKey(ev);
          expenseByType[expenseKey] = (expenseByType[expenseKey] || 0) + Math.abs(val);
        }
        monthlyData[month].net += val;
      }

      const sortedMonths = monthKeys;
      const monthStarts = sortedMonths.map(m => `${m}-01`);
      const labels = monthStarts;

      const revData = sortedMonths.map(m => monthlyData[m].revenue);
      const expData = sortedMonths.map(m => -monthlyData[m].expenses); // negative for chart

      // --- PnL Bar Chart ---
      const pnlCtx = document.getElementById('chart-pnl').getContext('2d');
      if (pnlChartInstance) pnlChartInstance.destroy();

      pnlChartInstance = new Chart(pnlCtx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Revenue',
              data: revData,
              backgroundColor: '#10b981',
              borderRadius: 4,
              barPercentage: 0.6,
            },
            {
              label: 'Expenses',
              data: expData,
              backgroundColor: '#ef4444',
              borderRadius: 4,
              barPercentage: 0.6,
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                title: function (ctxItems) {
                  const idx = ctxItems[0].dataIndex;
                  return monthStarts[idx];
                },
                label: function (ctx) {
                  const sym = currentUnit === 'usd' ? '$' : '';
                  const suf = currentUnit === 'usd' ? '' : ' SOL';
                  const val = Math.abs(ctx.raw);
                  return ctx.dataset.label + ': ' + sym + val.toLocaleString(undefined, { maximumFractionDigits: 2 }) + suf;
                }
              }
            }
          },
          scales: {
            x: { stacked: true, grid: { display: false } },
            y: {
              stacked: true,
              border: { display: false },
              ticks: {
                callback: function (val) {
                  if (val === 0) return '0';
                  const abs = Math.abs(val);
                  if (currentUnit === 'usd') {
                    if (abs >= 1000) return '$' + (val / 1000).toFixed(0) + 'k';
                    return '$' + val;
                  } else {
                    if (abs >= 1000) return (val / 1000).toFixed(1) + 'k SOL';
                    return val + ' SOL';
                  }
                }
              }
            }
          }
        }
      });

      // --- Breakdown Charts config ---
      const donutOptions = {
        responsive: true, maintainAspectRatio: false, cutout: '70%',
        plugins: {
          legend: { position: 'bottom', labels: { boxWidth: 10, usePointStyle: true, font: { size: 11 } } },
          tooltip: {
            callbacks: {
              label: function (ctx) {
                const total = ctx.dataset.data.reduce((acc, n) => acc + n, 0);
                const val = ctx.raw;
                const pct = total > 0 ? (val / total) * 100 : 0;
                const sym = currentUnit === 'usd' ? '$' : '';
                const suf = currentUnit === 'usd' ? '' : ' SOL';
                return `${ctx.label}: ${sym}${val.toLocaleString(undefined, { maximumFractionDigits: 2 })}${suf} (${pct.toFixed(1)}%)`;
              }
            }
          }
        }
      };

      // --- Income Chart ---
      const incomeCtx = document.getElementById('chart-income').getContext('2d');
      if (incomeChartInstance) incomeChartInstance.destroy();

      const incKeys = Object.keys(incomeByType).sort((a, b) => incomeByType[b] - incomeByType[a]);
      if (incKeys.length > 0) {
        incomeChartInstance = new Chart(incomeCtx, {
          type: 'doughnut',
          data: {
            labels: incKeys.map(k => typeLabels[k] || k),
            datasets: [{
              data: incKeys.map(k => incomeByType[k]),
              backgroundColor: incKeys.map(k => colorForBreakdownKey(k)),
              borderWidth: 0,
              hoverOffset: 4
            }]
          },
          options: donutOptions
        });
      }

      // --- Expense Chart ---
      const expCtx = document.getElementById('chart-expenses').getContext('2d');
      if (expenseChartInstance) expenseChartInstance.destroy();

      const expenseEntries = Object.entries(expenseByType).sort((a, b) => b[1] - a[1]);
      const expenseSliceLimit = 8;
      const expRows = expenseEntries.length <= expenseSliceLimit
        ? expenseEntries
        : [
          ...expenseEntries.slice(0, expenseSliceLimit - 1),
          ['Other', expenseEntries.slice(expenseSliceLimit - 1).reduce((sum, entry) => sum + entry[1], 0)]
        ];

      if (expRows.length > 0) {
        expenseChartInstance = new Chart(expCtx, {
          type: 'doughnut',
          data: {
            labels: expRows.map(entry => entry[0]),
            datasets: [{
              data: expRows.map(entry => entry[1]),
              backgroundColor: expRows.map(entry => colorForBreakdownKey(entry[0])),
              borderWidth: 0,
              hoverOffset: 4
            }]
          },
          options: donutOptions
        });
      }
    }


    // ── Unit state ──────────────────────────────────────────────────────────────
    let currentUnit = 'usd';

    function setUnit(unit) {
      if (unit === currentUnit) return;
      // Cancel any in-flight animation so the snap is clean
      if (rafId) { cancelAnimationFrame(rafId); rafId = null; }

      currentUnit = unit;
      document.getElementById('btn-usd').classList.toggle('active', unit === 'usd');
      document.getElementById('btn-sol').classList.toggle('active', unit === 'sol');

      document.querySelectorAll('.ev-sol').forEach(el => {
        el.style.display = unit === 'sol' ? '' : 'none';
      });
      document.querySelectorAll('.ev-usd').forEach(el => {
        el.textContent = unit === 'usd'
          ? formatUsd(parseFloat(el.dataset.usd))
          : formatSol(parseFloat(el.dataset.sol));
      });

      // Update month separator nets
      document.querySelectorAll('.month-sep-net').forEach(el => {
        const netUsd = parseFloat(el.dataset.netUsd);
        el.textContent = (unit === 'usd' ? formatUsd(netUsd) : formatSol(usdToSol(netUsd))) + ' net';
        el.className = 'month-sep-net ' + (netUsd >= 0 ? 'positive' : 'negative');
      });

      // Snap header to current target in the new unit
      updateHeaderDisplay(targetProfit, targetRevenue, targetExpenses, true);
    }

    // ── Formatting helpers ──────────────────────────────────────────────────────
    function formatUsd(n) {
      if (n === 0) return '$0';
      const abs = Math.abs(n);
      const str = abs >= 1000
        ? '$' + Math.round(abs).toLocaleString()
        : '$' + abs.toFixed(2);
      return n < 0 ? '-' + str : str;
    }

    function formatSol(n) {
      if (n === 0) return '0 SOL';
      const abs = Math.abs(n);
      const str = abs.toFixed(abs < 0.01 ? 6 : abs < 1 ? 4 : 3) + ' SOL';
      return n < 0 ? '-' + str : str;
    }

    function formatAmount(usd, sol) {
      return currentUnit === 'usd' ? formatUsd(usd) : formatSol(sol);
    }

    // ── Recent SOL price estimate ────────────────────────────────────────────────
    // Sample the most-recent entries with a non-zero SOL amount and take the
    // median implied price. This is only used for the header SOL display.
    function solPrice() {
      const candidates = [];
      for (let i = TIMELINE.length - 1; i >= 0 && candidates.length < 20; i--) {
        const e = TIMELINE[i];
        if (e.amount_sol !== 0) {
          const p = Math.abs(e.amount_usd / e.amount_sol);
          if (p > 1) candidates.push(p);
        }
      }
      if (!candidates.length) return 150; // reasonable fallback
      candidates.sort((a, b) => a - b);
      return candidates[Math.floor(candidates.length / 2)];
    }

    // ── Build period tabs ───────────────────────────────────────────────────────
    const years = [...new Set(TIMELINE.map(e => e.date.slice(0, 4)).filter(y => y !== '0000'))].sort().reverse();
    const tabsEl = document.getElementById('period-tabs');

    function buildTabs(activeYear) {
      while (tabsEl.firstChild) tabsEl.removeChild(tabsEl.firstChild);

      const allBtn = document.createElement('button');
      allBtn.className = 'period-btn' + (activeYear === 'all' ? ' active' : '');
      allBtn.textContent = 'All time';
      allBtn.onclick = () => render('all');
      tabsEl.appendChild(allBtn);

      years.forEach(y => {
        const btn = document.createElement('button');
        btn.className = 'period-btn' + (activeYear === y ? ' active' : '');
        btn.textContent = y;
        btn.onclick = () => render(y);
        tabsEl.appendChild(btn);
      });
    }

    // ── Render timeline ─────────────────────────────────────────────────────────
    let allRows = [];

    function render(yearFilter, { scrollToBottom = false } = {}) {
      const filteredEvents = yearFilter === 'all'
        ? TIMELINE
        : TIMELINE.filter(e => e.date.startsWith(yearFilter));

      renderDashboard(filteredEvents);
      buildTabs(yearFilter);

      // Scroll to top so the header reflects the beginning of the filtered period.
      // (Skip on initial load — we'll scroll to the bottom instead.)
      if (!scrollToBottom) window.scrollTo(0, 0);

      const events = yearFilter === 'all'
        ? TIMELINE
        : TIMELINE.filter(e => e.date.startsWith(yearFilter));

      const container = document.getElementById('timeline');
      while (container.firstChild) container.removeChild(container.firstChild);
      allRows = [];

      if (events.length === 0) {
        const msg = document.createElement('div');
        msg.style.cssText = 'text-align:center;color:var(--muted);padding:60px 0;font-size:14px';
        msg.textContent = 'No events found for the selected period.';
        container.appendChild(msg);
        // Reset header so it doesn't show a previous period's totals
        setHeaderInstant(0, 0, 0);
        return;
      }

      // Group by month (events are oldest-first)
      const byMonth = new Map();
      for (const ev of events) {
        const mo = ev.date.slice(0, 7);
        if (!byMonth.has(mo)) byMonth.set(mo, []);
        byMonth.get(mo).push(ev);
      }

      for (const [mo, evs] of byMonth) {
        container.appendChild(buildMonthSep(mo, evs));
        for (const ev of evs) {
          const row = buildRow(ev);
          container.appendChild(row);
          allRows.push(row);
        }
      }

      // Recompute period-relative running totals from the filtered event set.
      // The Rust-precomputed cumulative_* fields are all-time totals; reading them
      // directly in a year-filtered view would show e.g. 3 years of revenue in
      // the "2025" tab. Instead we walk the filtered events and overwrite each
      // row's dataset with period-local sums.
      let pProfit = 0, pRevenue = 0, pExpenses = 0;
      for (let i = 0; i < events.length; i++) {
        const ev = events[i];
        if (ev.is_pnl) {
          if (ev.amount_usd >= 0) pRevenue += ev.amount_usd;
          else pExpenses += Math.abs(ev.amount_usd);
          pProfit += ev.amount_usd;
        }
        // allRows[i] maps 1-to-1 with events[i] (separators are not in allRows)
        allRows[i].dataset.profit = pProfit.toFixed(2);
        allRows[i].dataset.revenue = pRevenue.toFixed(2);
        allRows[i].dataset.expenses = pExpenses.toFixed(2);
      }

      // Seed header with the period's final totals (read from the recomputed last row)
      const lastRow = allRows[allRows.length - 1];
      const seedP = parseFloat(lastRow.dataset.profit);
      const seedR = parseFloat(lastRow.dataset.revenue);
      const seedE = parseFloat(lastRow.dataset.expenses);
      setHeaderInstant(seedP, seedR, seedE);
      targetProfit = seedP;
      targetRevenue = seedR;
      targetExpenses = seedE;

      // Mark the last row as the initial anchor (header reflects totals through it).
      anchorIdx = null;
      setAnchor(allRows.length - 1);
    }

    function monthLabel(mo) {
      const [y, m] = mo.split('-');
      const months = ['January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'];
      return months[parseInt(m, 10) - 1] + ' ' + y;
    }

    function buildMonthSep(mo, evs) {
      let netUsd = 0;
      for (const ev of evs) { if (ev.is_pnl) netUsd += ev.amount_usd; }

      const div = document.createElement('div');
      div.className = 'month-sep';
      div.dataset.month = mo;

      const line1 = document.createElement('div');
      line1.className = 'month-sep-line';

      const lbl = document.createElement('span');
      lbl.className = 'month-sep-label';
      lbl.textContent = monthLabel(mo);

      const netEl = document.createElement('span');
      netEl.className = 'month-sep-net ' + (netUsd >= 0 ? 'positive' : 'negative');
      // Store USD net so setUnit() can reformat it without re-iterating events
      netEl.dataset.netUsd = netUsd;
      netEl.textContent = (currentUnit === 'usd' ? formatUsd(netUsd) : formatSol(usdToSol(netUsd))) + ' net';

      const line2 = document.createElement('div');
      line2.className = 'month-sep-line';

      div.appendChild(line1);
      div.appendChild(lbl);
      div.appendChild(netEl);
      div.appendChild(line2);
      return div;
    }

    function rowClass(ev) {
      if (!ev.is_pnl) return 'ev-neutral';
      return ev.amount_usd >= 0 ? 'ev-income' : 'ev-expense';
    }

    function dotGlyph(ev) {
      if (!ev.is_pnl) return '○';
      // Use ● for both income and expense — CSS color distinguishes them (green/red).
      // ◌ is reserved for genuine zero-amount P&L events (e.g. fully-SFDP vote costs).
      if (ev.amount_usd === 0) return '◌';
      return '●';
    }

    function buildRow(ev) {
      const div = document.createElement('div');
      div.className = 'event-row ' + rowClass(ev);
      div.dataset.profit = ev.cumulative_profit_usd.toFixed(2);
      div.dataset.revenue = ev.cumulative_revenue_usd.toFixed(2);
      div.dataset.expenses = ev.cumulative_expenses_usd.toFixed(2);

      const dateEl = document.createElement('span');
      dateEl.className = 'ev-date';
      dateEl.textContent = ev.date;

      const dotEl = document.createElement('span');
      dotEl.className = 'ev-dot';
      dotEl.dataset.type = ev.event_type;
      dotEl.textContent = dotGlyph(ev);

      const labelDiv = document.createElement('div');
      labelDiv.className = 'ev-label';
      const mainEl = document.createElement('div');
      mainEl.className = 'ev-label-main';
      mainEl.textContent = ev.label;
      labelDiv.appendChild(mainEl);
      if (ev.sublabel) {
        const subEl = document.createElement('div');
        subEl.className = 'ev-label-sub';
        subEl.textContent = ev.sublabel;
        labelDiv.appendChild(subEl);
      }

      const solEl = document.createElement('span');
      solEl.className = 'ev-sol';
      solEl.dataset.sol = ev.amount_sol;
      solEl.textContent = formatSol(ev.amount_sol);
      solEl.style.display = currentUnit === 'sol' ? '' : 'none';

      const usdEl = document.createElement('span');
      usdEl.className = 'ev-usd';
      usdEl.dataset.sol = ev.amount_sol;
      usdEl.dataset.usd = ev.amount_usd;
      usdEl.textContent = formatAmount(ev.amount_usd, ev.amount_sol);

      div.appendChild(dateEl);
      div.appendChild(dotEl);
      div.appendChild(labelDiv);
      div.appendChild(solEl);
      div.appendChild(usdEl);
      return div;
    }

    // ── Sticky header rewind ────────────────────────────────────────────────────
    let targetProfit = 0;
    let targetRevenue = 0;
    let targetExpenses = 0;
    let displayProfit = 0;
    let displayRevenue = 0;
    let displayExpenses = 0;
    let rafId = null;

    // Find the last (newest, bottommost) row still visible in the viewport.
    // For a chronological (oldest→newest) timeline this gives the most recent event
    // currently in view, so the header totals build up as you scroll forward.
    function findBottomRow() {
      const viewBottom = window.innerHeight;
      let lo = 0, hi = allRows.length - 1, found = null;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        const rect = allRows[mid].getBoundingClientRect();
        if (rect.top < viewBottom) { found = mid; lo = mid + 1; }
        else { hi = mid - 1; }
      }
      return found;
    }

    function updateHeaderDisplay(profit, revenue, expenses, instant) {
      if (instant) {
        displayProfit = profit; displayRevenue = revenue; displayExpenses = expenses;
        paintHeader();
        return;
      }
      targetProfit = profit;
      targetRevenue = revenue;
      targetExpenses = expenses;
      if (!rafId) rafId = requestAnimationFrame(animateHeader);
    }

    function animateHeader() {
      rafId = null;
      const LERP = 0.22;
      displayProfit += (targetProfit - displayProfit) * LERP;
      displayRevenue += (targetRevenue - displayRevenue) * LERP;
      displayExpenses += (targetExpenses - displayExpenses) * LERP;
      paintHeader();

      const dx = Math.abs(targetProfit - displayProfit)
        + Math.abs(targetRevenue - displayRevenue)
        + Math.abs(targetExpenses - displayExpenses);
      if (dx > 0.5) {
        rafId = requestAnimationFrame(animateHeader);
      } else {
        displayProfit = targetProfit;
        displayRevenue = targetRevenue;
        displayExpenses = targetExpenses;
        paintHeader();
      }
    }

    function paintHeader() {
      if (currentUnit === 'usd') {
        profitEl.textContent = formatUsd(displayProfit);
        revenueEl.textContent = formatUsd(displayRevenue);
        expensesEl.textContent = formatUsd(displayExpenses);
      } else {
        const sp = currentSolPrice();
        profitEl.textContent = formatSol(displayProfit / sp);
        revenueEl.textContent = formatSol(displayRevenue / sp);
        expensesEl.textContent = formatSol(displayExpenses / sp);
      }

      profitEl.className = 'stat-value ' + (displayProfit >= 0 ? 'positive' : 'negative');
      revenueEl.className = 'stat-value positive';
      expensesEl.className = 'stat-value negative'; // expenses are a cost — red is standard
    }

    function setHeaderInstant(profit, revenue, expenses) {
      targetProfit = profit; targetRevenue = revenue; targetExpenses = expenses;
      displayProfit = profit; displayRevenue = revenue; displayExpenses = expenses;
      paintHeader();
    }

    // ── Scroll handler (rAF-gated to avoid forced layout on the scroll thread) ───
    let scrollTicking = false;
    let anchorIdx = null;

    function setAnchor(idx) {
      if (idx === anchorIdx) return;
      if (anchorIdx !== null && allRows[anchorIdx]) {
        allRows[anchorIdx].classList.remove('row-anchor');
      }
      anchorIdx = idx;
      if (idx !== null && allRows[idx]) {
        allRows[idx].classList.add('row-anchor');
      }
    }

    window.addEventListener('scroll', () => {
      if (scrollTicking) return;
      scrollTicking = true;
      requestAnimationFrame(() => {
        scrollTicking = false;
        const idx = findBottomRow();
        if (idx === null) return;
        setAnchor(idx);
        const row = allRows[idx];
        updateHeaderDisplay(
          parseFloat(row.dataset.profit),
          parseFloat(row.dataset.revenue),
          parseFloat(row.dataset.expenses),
          false
        );
      });
    }, { passive: true });

    // ── Init ────────────────────────────────────────────────────────────────────
    render('all', { scrollToBottom: true });
    window.scrollTo(0, document.body.scrollHeight);
  </script>
</body>

</html>
